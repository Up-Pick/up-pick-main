# 워크플로우의 이름을 지정합니다. GitHub Actions 탭에서 이 이름으로 표시됩니다.
name: Dev CI/CD

# 워크플로우의 동시 실행(concurrency) 설정입니다.
concurrency:
  group: uppick-dev-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# 워크플로우가 언제 실행될지를 정의하는 "트리거" 설정입니다.
on:
  push:
    branches: [ "dev" ] # 'main' 브랜치에 코드가 푸시(push)될 때마다 실행됩니다.

# 실제 작업(Job)들을 정의합니다. 이 워크플로우에는 하나의 작업만 있습니다.
jobs:
  build-and-deploy:
    # 이 작업을 실행할 가상 머신의 종류를 지정합니다. 최신 Ubuntu 버전을 사용합니다.
    runs-on: ubuntu-latest
    
    # 이 작업 내에서 실행될 단계(Step)들의 목록입니다.
    steps:
      # 1. 소스 코드 체크아웃
      # uses: 다른 사람이 만들어 둔 액션을 가져와 사용합니다.
      # actions/checkout@v3: GitHub 리포지토리의 소스 코드를 가상 머신으로 내려받는 공식 액션입니다.
      - name: Checkout Source Code
        uses: actions/checkout@v3

      # 2. JDK 21 설치
      # actions/setup-java@v3: 특정 버전의 Java(JDK) 환경을 설정해주는 액션입니다.
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      # 3. Gradle 실행 권한 부여
      # run: 가상 머신에서 직접 셸 명령어를 실행합니다.
      # Linux/macOS 환경에서 gradlew 파일을 실행 가능하게 만들기 위해 권한을 변경합니다.
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      # 4. Gradle로 빌드
      # ./gradlew build: Spring Boot 애플리케이션을 빌드하여 실행 가능한 .jar 파일을 생성합니다.
      # REST Docs 관련 태스크도 제외하여 테스트 없이 빌드할 수 있도록 합니다.
      - name: Build with Gradle
        run: ./gradlew build -x test -x asciidoctor -x generateRestDocsIndex

      # 5. AWS 자격 증명 설정
      # aws-actions/configure-aws-credentials@v2: GitHub Secrets에 저장된 AWS 키를 사용하여 AWS CLI 접근을 설정합니다.
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.DEV_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.DEV_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.DEV_AWS_REGION }}

      # 6. Amazon ECR에 로그인
      # aws-actions/amazon-ecr-login@v1: 위에서 설정된 AWS 자격 증명을 이용해 ECR에 Docker 클라이언트를 로그인시킵니다.
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      # 7. Docker 이미지 빌드 및 ECR에 푸시
      # docker/build-push-action@v4: Dockerfile을 사용해 이미지를 빌드하고, 지정된 레지스트리(ECR)로 푸시합니다.
      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          # ECR_REGISTRY: login-ecr 스텝의 결과물(레지스트리 주소)을 가져옵니다.
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          # ECR_REPOSITORY_URI: GitHub Secrets에서 ECR 리포지토리 주소를 가져옵니다.
          IMAGE_TAG: ${{ github.sha }} # 이미지 태그로 Git 커밋 해시를 사용하여 버전을 명확히 합니다.
        run: |
          docker build -t $ECR_REGISTRY/${{ secrets.DEV_ECR_REPOSITORY_URI }}:$IMAGE_TAG .
          docker push $ECR_REGISTRY/${{ secrets.DEV_ECR_REPOSITORY_URI }}:$IMAGE_TAG
          # latest 태그로도 푸시하여 배포 시 항상 최신 버전을 가리키도록 합니다.
          docker tag $ECR_REGISTRY/${{ secrets.DEV_ECR_REPOSITORY_URI }}:$IMAGE_TAG $ECR_REGISTRY/${{ secrets.DEV_ECR_REPOSITORY_URI }}:latest
          docker push $ECR_REGISTRY/${{ secrets.DEV_ECR_REPOSITORY_URI }}:latest

      # 8. EC2 인스턴스에 배포
      # appleboy/ssh-action@master: SSH를 통해 원격 서버(EC2)에 접속하여 명령어를 실행하는 액션입니다.
      - name: Deploy to EC2 instance
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.DEV_EC2_PUBLIC_IP }}
          username: ubuntu # Ubuntu AMI의 기본 사용자 이름
          key: ${{ secrets.DEV_EC2_SSH_KEY }}
          script: |
            # 0. 혹시 모를 에러 방지를 위해 스크립트 실패 시 즉시 중단
            set -e

            # 1. AWS CLI를 통해 ECR에 로그인합니다. (EC2 인스턴스에 AWS CLI가 설치되어 있어야 합니다)
            aws ecr get-login-password --region ${{ secrets.DEV_AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}
            
            # 2. 기존에 실행 중인 앱 컨테이너가 있다면 중지하고 삭제합니다. (|| true는 컨테이너가 없을 때 오류가 나지 않도록 함)
            if [ $(docker ps -a -q -f name=my-app-container) ]; then
              docker stop my-app-container || true
              docker rm my-app-container || true
            fi
            
            # 3. Docker Hub에서 최신 이미지를 받아옵니다.
            docker pull ${{ steps.login-ecr.outputs.registry }}/${{ secrets.DEV_ECR_REPOSITORY_URI }}:latest
            
            # 4. Docker 컨테이너를 실행합니다.
            # -d: 백그라운드에서 실행
            # --name: 컨테이너에 'my-app-container'라는 이름을 부여
            # -p 8080:8080: 호스트(EC2)의 8080 포트와 컨테이너의 8080 포트를 연결
            # -e: 컨테이너 내부에 환경 변수를 주입 (DB 연결 정보)
            docker run -d --name my-app-container -p 8080:8080 \
              -e SPRING_PROFILES_ACTIVE=dev \
              -e DB_URL=${{ secrets.DEV_DB_URL }} \
              -e DB_USER=${{ secrets.DEV_DB_USER }} \
              -e DB_PASS=${{ secrets.DEV_DB_PASS }} \
              -e JWT_KEY=${{ secrets.DEV_JWT_KEY }} \
              ${{ steps.login-ecr.outputs.registry }}/${{ secrets.DEV_ECR_REPOSITORY_URI }}:latest