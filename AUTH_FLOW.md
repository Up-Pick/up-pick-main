# 마이크로서비스 인증/인가 흐름

이 문서는 API 게이트웨이(`uppick-main`)와 내부 마이크로서비스(`member-service` 등) 간의 인증 및 인가 흐름에 대한 표준 패턴을 설명합니다.

**결론: 우리는 `패턴 B`를 표준 방식으로 채택합니다.**

---

## 패턴 A: JWT 토큰을 그대로 전달하는 방식

Client가 보낸 JWT를 게이트웨이가 받아 내부 서비스로 그대로 전달하는 방식입니다.

1.  **Client**가 `Authorization: Bearer <JWT>` 헤더를 담아 **`uppick-main`**(게이트웨이)에 요청을 보냅니다.
2.  **`uppick-main`**은 해당 JWT가 유효한지 1차로 검증합니다.
3.  검증 후, **`uppick-main`**은 원래의 `Authorization` 헤더를 **그대로 포함**해서 **`member-service`**를 호출합니다.
4.  **`member-service`**는 전달받은 JWT를 **다시 검증**해서 사용자가 누구인지 파악하고 인가(Authorization) 처리를 합니다.

-   **장점**: 구현이 비교적 단순합니다.
-   **단점**: 모든 내부 서비스가 JWT 검증 로직과 Secret Key를 가져야 하고, 모든 요청마다 중복으로 JWT를 검증하는 오버헤드가 발생합니다.

---

## 패턴 B: 게이트웨이에서 토큰을 종료시키는 방식 (권장)

게이트웨이가 인증을 완전히 책임지고, 내부 서비스에는 신뢰할 수 있는 헤더를 통해 사용자 정보만 전달하는 방식입니다.

1.  **Client**가 `Authorization: Bearer <JWT>` 헤더를 담아 **`uppick-main`**(게이트웨이)에 요청을 보냅니다.
2.  **`uppick-main`**은 해당 JWT를 완벽하게 검증하고, 토큰의 인증 역할을 여기서 **종료**시킵니다.
3.  JWT에서 사용자 ID, 권한 등 핵심 정보만 추출합니다.
4.  추출한 정보를 새로운 내부용 헤더(예: `X-User-Id: 123`, `X-User-Roles: ROLE_USER`)에 담습니다.
5.  **`uppick-main`**은 원래의 `Authorization` 헤더는 제거하고, 이 **새로운 내부용 헤더**를 포함해서 **`member-service`**를 호출합니다.
6.  **`member-service`**는 안전한 내부 네트워크를 통해 들어온 요청이므로, JWT를 다시 검증할 필요 없이 내부용 헤더에 담긴 사용자 정보를 **신뢰하고** 바로 인가(Authorization) 처리에 사용합니다.

-   **장점**: 역할 분리가 명확합니다. (인증은 게이트웨이, 인가는 각 서비스). 내부 서비스는 JWT Secret Key를 몰라도 되며, 중복 검증 오버헤드가 없습니다.
-   **단점**: 외부에서 내부용 헤더를 위조할 수 없도록 내부 네트워크가 안전하게 구성되어 있다고 신뢰해야 합니다. (Docker Compose, Kubernetes 등의 환경에서는 기본적으로 보장됩니다.)

---

**선택:**

우리는 **패턴 B**를 구현합니다. 이 방식은 역할 분리가 명확하고, 컨테이너 기반의 마이크로서비스 환경에서 더 효율적이고 안전합니다.
